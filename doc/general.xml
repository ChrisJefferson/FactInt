<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  general.xml        FactInt documentation         Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$      ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:General">
<Heading>The General Factorization Routine</Heading>

<!-- #################################################################### -->

<Section Label="sec:Factors">
<Heading>The method for <C>Factors</C></Heading>

The &FactInt; package provides a better method for the operation
<C>Factors</C> for integer arguments, which supersedes the one included in
the &GAP; Library:

<ManSection>
  <Meth Name="Factors" Arg="n" Label="FactInt's method, for integers"/>
  <Returns>
    A sorted list of the prime factors of <A>n</A>.
  </Returns>
  <Description>
    If the method fails to compute the prime factorization of <A>n</A>,
    an error is signalled.
    <Index Key="primality of the factors">primality of the factors</Index>
    The returned factors pass the built-in probabilistic primality test of
    &GAP; (<C>IsProbablyPrimeInt</C>, see the &GAP; Reference Manual).
    The same holds for all other factorization routines provided by this
    package. <P/>

    It follows a rough description how the factorization method works: <P/>

    First of all it checks whether <M>n = b^k \pm 1</M> for some <M>b</M>,
    <M>k</M> and looks for factors corresponding to polynomial factors of
    <M>x^k \pm 1</M>.
    Provided that <M>b</M> and <M>k</M> are sufficiently small, factors that
    do not correspond to polynomial factors are taken from Richard P. Brent's
    Factor Tables&nbsp;<Cite Key="Brent04"/>.
    The code for accessing these tables has been contributed by Frank Lübeck.
    <P/>

    Then the method uses trial division and a number of cheap methods for
    various special cases.
    After the small and other <Q>easy</Q> factors have been found this way,
    &FactInt;'s method searches for <Q>medium-sized</Q> factors using
    Pollard's Rho (by the library function <C>FactorsRho</C>, see the &GAP;
    Reference Manual), Pollard's&nbsp;<M>p-1</M>
    (see&nbsp;<Ref Func="FactorsPminus1" Label="Pollard's p-1"/>),
    Williams'&nbsp;<M>p+1</M>
    (see&nbsp;<Ref Func="FactorsPplus1" Label="Williams' p+1"/>)
    and the Elliptic Curves Method (ECM, 
    see&nbsp;<Ref Func="FactorsECM" Label="Elliptic Curves Method, ECM"/>)
    in this order. <P/>

    If there is still an unfactored part remaining after that,
    it is factored using the Multiple Polynomial Quadratic Sieve (MPQS,
    see&nbsp;<Ref Func="FactorsMPQS"
                  Label="Multiple Polynomial Quadratic Sieve, MPQS"/>).
    <P/>

    The following options are interpreted:

    <List>
      <Mark><A>TDHints</A></Mark>
      <Item>
        A list of additional trial divisors.
        This is useful only if certain primes&nbsp;<M>p</M> are expected to
        divide <M>n</M> with probability significantly larger than
        <M>\frac{1}{p}</M>.
      </Item>
      <Mark><A>RhoSteps</A></Mark>
      <Item>
        The number of steps for Pollard's Rho.
      </Item>
      <Mark><A>RhoCluster</A></Mark>
      <Item>
        The number of steps between two gcd computations in Pollard's Rho.
      </Item>
      <Mark><A>Pminus1Limit1</A> / <A>Pminus1Limit2</A></Mark>
      <Item>
        The first- / second stage limit for Pollard's&nbsp;<M>p-1</M>
        (see&nbsp;<Ref Func="FactorsPminus1" Label="Pollard's p-1"/>).
      </Item>
      <Mark><A>Pplus1Residues</A></Mark>
      <Item>
        The number of residues to be tried by Williams'&nbsp;<M>p+1</M>
        (see&nbsp;<Ref Func="FactorsPplus1" Label="Williams' p+1"/>).
      </Item>
      <Mark><A>Pplus1Limit1</A> / <A>Pplus1Limit2</A></Mark>
      <Item>
        The first- / second stage limit for Williams'&nbsp;<M>p+1</M>
        (see&nbsp;<Ref Func="FactorsPplus1" Label="Williams' p+1"/>).
      </Item>
      <Mark><A>ECMCurves</A></Mark>
      <Item>
        The number of elliptic curves to be tried by the
        Elliptic Curves Method (ECM)
        (see&nbsp;<Ref Func="FactorsECM"
                       Label="Elliptic Curves Method, ECM"/>).
        Also admissible: a function that takes the number <M>n</M> to be
        factored as an argument and returns the desired number
        of curves to be tried.
      </Item>
      <Mark><A>ECMLimit1</A> / <A>ECMLimit2</A></Mark>
      <Item>
        The initial first- / second stage limit for ECM
        (see&nbsp;<Ref Func="FactorsECM"
                       Label="Elliptic Curves Method, ECM"/>).
      </Item>
      <Mark><A>ECMDelta</A></Mark>
      <Item>
        The increment per curve for the first
        stage limit in ECM. The second stage limit is adjusted appropriately
        (see&nbsp;<Ref Func="FactorsECM"
                       Label="Elliptic Curves Method, ECM"/>).
      </Item>
      <Mark><A>ECMDeterministic</A></Mark>
      <Item>
        If true, ECM chooses its curves deterministically, i.e. repeatable
        (see&nbsp;<Ref Func="FactorsECM"
                       Label="Elliptic Curves Method, ECM"/>).
      </Item>
      <Mark>FBMethod</Mark>
      <Item>
        Specifies which of the factor base methods should be
        used to do the <Q>hard work</Q>. Currently implemented:
        <C>"CFRAC"</C> and <C>"MPQS"</C>
        (see&nbsp;<Ref Func="FactorsCFRAC"
                      Label="Continued Fraction Algorithm, CFRAC"/>
        and&nbsp;<Ref Func="FactorsMPQS"
                      Label="Multiple Polynomial Quadratic Sieve, MPQS"/>,
        respectively).
        Default: <C>"MPQS"</C>.
      </Item>
    </List>

    For the use of the &GAP; Options Stack, see Chapter <E>Options Stack</E>
    in the &GAP; Reference Manual. <P/>

    Setting <A>RhoSteps</A>, <A>Pminus1Limit1</A>, <A>Pplus1Residues</A>,
    <A>Pplus1Limit1</A>, <A>ECMCurves</A> or <A>ECMLimit1</A> equal to zero
    switches the respective method off. The method chooses defaults for all
    option values that are not explicitly set by the user. The option values
    are also interpreted by the routines for the particular factorization
    methods described in the next chapter.
<Example>
<![CDATA[
gap> Factors( Factorial(44) + 1 );
[ 694763, 9245226412016162109253, 413852053257739876455072359 ]
gap> Factors( 2^997 - 1 );
[ 167560816514084819488737767976263150405095191554732902607,
  7993430605360222292860936960123884061988016846627213757686887976005930025638\
602973712891518592878944687759622084106508783413855778177367022158878920741413\
700868182301410439178049533828082651513160945607018874830040978453228378816647\
358334681553 ]
]]>
</Example>
  </Description>
</ManSection>

The above method for <C>Factors</C> calls the following function,
which is the actual <Q>working horse</Q> of this package:

<ManSection>
  <Func Name="FactInt" Arg="n" Label="factorization of an integer"/>
  <Returns>
    A list of two lists, where the first list contains the determined
    prime factors of&nbsp;<A>n</A> and the second list contains the
    remaining unfactored parts of&nbsp;<A>n</A>, if there are any.
  </Returns>
  <Description>
    This function interprets all options which are interpreted by the
    method for <C>Factors</C> described above. In addition, it interprets
    the options <A>cheap</A> and <A>FactIntPartial</A>.
    If the option <A>cheap</A> is set, only usually
    cheap factorization attempts are made.
    If the option <A>FactIntPartial</A> is set, the factorization process
    is stopped before invoking the (usually time-consuming) MPQS or CFRAC,
    if the number of digits of the remaining unfactored part exceeds the
    bound passed as option value <A>MPQSLimit</A> or <A>CFRACLimit</A>,
    respectively. <P/>

    <C>Factors(<A>n</A>)</C> is equivalent to
    <C>FactInt(<A>n</A>:<A>cheap</A>:=false,
                        <A>FactIntPartial</A>:=false)[1]</C>.
<Example>
<![CDATA[
gap> FactInt( Factorial(300) + 1 : cheap );
[ [ 461, 259856122109, 995121825812791, 3909669044842609, 4220826953750952739,
      14841043839896940772689086214475144339 ],
  [ 10483128823176572317398383656043859405333629662907393256352061868792876450\
580106888272460615410656311193456740818340859600641445970372439235869682208979\
384309498719255615067943353399357029226058930732298505581697749539842674165663\
346174704662364145104265524709331550541782037094517458717017420005463846144727\
565841824785318809625948572758696907279733563594352516014206081210368516157890\
709802912711149521530885498556124466779020824562030140449992853222252458594688\
152833725706178959319799211283640357942345263781351 ] ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:Info">
<Heading>Getting information about the factoring process</Heading>

<Index Key="information about factoring process">
  information about factoring process
</Index>

Optionally, the &FactInt; package prints information on the progress of
the factorization process:

<ManSection>
  <InfoClass Name="IntegerFactorizationInfo"
             Label="FactInt's Info class"/>
  <InfoClass Name="InfoFactInt"
             Label="shorthand for IntegerFactorizationInfo"/>
  <Description>
    This Info class allows to monitor what happens during the factoring
    process. For a description of the Info mechanism, see
    Section <E>Info Functions</E> in the &GAP; Reference Manual. <P/>

    If <C>InfoLevel(IntegerFactorizationInfo) = 1</C>, then basic information
    about the factoring techniques used is displayed. If this InfoLevel has
    value&nbsp;2, then additionally all <Q>relevant</Q> steps in the
    factoring algorithms are mentioned. If it is set equal to&nbsp;3, then
    large amounts of details of the progress of the factoring process are
    shown. The informational output is usually not literally the same in
    each factorization attempt to a given integer with given parameters. <P/>

    For convenience, <C>FactIntInfo(<A>level</A>)</C> sets the
    <C>InfoLevel</C> of <C>IntegerFactorizationInfo</C> to the positive
    integer <A>level</A>. <C>FactIntInfo(<A>level</A>);</C> is equivalent
    to <C>SetInfoLevel( IntegerFactorizationInfo,<A>level</A>);</C>.
    There is a shorthand <C>FactInfo</C> for <C>FactIntInfo</C>. <P/>

    The timings in the example below are given for a Pentium&nbsp;200
    under Windows as a reference machine (such a machine was a fast PC at
    the time the first version of this package has been written).
<Log>
<![CDATA[
gap> FactIntInfo(2);
gap> Factors(1459^60-1);
#I  
#I  Check for n = b^k +/- 1
#I  
697136005439518321339364341462731479643931164718338822169985761598533184155968\
687683267309071831767783053294661533309653344501590527857911683460652704454392\
2114173712945384179913214273324400 = 1459^60 - 1
#I  The factors corresponding to polynomial factors are
[ 1458, 1460, 2127223, 2128682, 2130141, 4528179181405, 4531280671081, 
  4534390675481, 20518450806493943781446161, 20532514165758816624282961, 
  20546596816316767296268561, 
  421584732115767299535558510031830342788459718258721 ]
#I  Intermediate result : [ [ 4531280671081, 20546596816316767296268561 ], 
  [ 1458, 1460, 2127223, 2128682, 2130141, 4528179181405, 4534390675481, 
      20518450806493943781446161, 20532514165758816624282961, 
      421584732115767299535558510031830342788459718258721 ] ]
#I  
#I  Factors already found : [ 4531280671081, 20546596816316767296268561 ]
#I  
#I  Trial division by all primes p < 1000
#I  Intermediate result : [ [ 2, 3, 3, 3, 3, 3, 3 ], [  ] ]
#I  Intermediate result : [ [ 2, 2, 5, 73 ], [  ] ]
#I  Intermediate result : [ [ 7, 303889 ], [  ] ]
#I  Intermediate result : [ [ 2, 1064341 ], [  ] ]
#I  Intermediate result : [ [ 3, 13, 193, 283 ], [  ] ]
#I  Intermediate result : [ [ 5, 11, 521, 158024051 ], [  ] ]
#I  Intermediate result : [ [ 31, 146270666951 ], [  ] ]
#I  Intermediate result : [ [ 61 ], [ 336368046008097439040101 ] ]
#I  
#I  Factors already found : [ 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 5, 5, 7, 11, 
  13, 31, 61, 73, 193, 283, 521, 303889, 1064341, 158024051, 146270666951, 
  4531280671081, 20546596816316767296268561 ]
#I  
#I  Trial division by some already known primes
#I  
#I  Check for perfect powers
#I  
#I  Pollard's Rho
Steps = 16384, Cluster = 1638
Number to be factored : 
336368046008097439040101
#I  Intermediate result : [ [ 2251, 149430495783250750351 ], [  ] ]
#I  
#I  Pollard's Rho
Steps = 16384, Cluster = 1638
Number to be factored : 
20532514165758816624282961
#I  
#I  Pollard's Rho
Steps = 16384, Cluster = 1638
Number to be factored : 
421584732115767299535558510031830342788459718258721
#I  
#I  Factors already found : [ 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 5, 5, 7, 11, 
  13, 31, 61, 73, 193, 283, 521, 2251, 303889, 1064341, 158024051, 
  146270666951, 4531280671081, 149430495783250750351, 
  20546596816316767296268561 ]
#I  
#I  Pollard's p - 1
Limit1 = 10000, Limit2 = 400000
Number to be factored : 
20532514165758816624282961
#I  Initializing prime differences list, PrimeDiffLimit = 1000000
#I  p-1 for n = 20532514165758816624282961
a : 2, Limit1 : 10000, Limit2 : 400000
#I  First stage
#I  Second stage
#I  
#I  Pollard's p - 1
Limit1 = 10000, Limit2 = 400000
Number to be factored : 
421584732115767299535558510031830342788459718258721
#I  p-1 for n = 421584732115767299535558510031830342788459718258721
a : 2, Limit1 : 10000, Limit2 : 400000
#I  First stage
#I  Second stage
#I  
#I  Williams' p + 1
Residues = 2, Limit1 = 2000, Limit2 = 80000
Number to be factored : 
20532514165758816624282961
#I  p+1 for n = 20532514165758816624282961
Residues : 2, Limit1 : 2000, Limit2 : 80000
#I  Residue no. 1
#I  Residue no. 2
#I  
#I  Williams' p + 1
Residues = 2, Limit1 = 2000, Limit2 = 80000
Number to be factored : 
421584732115767299535558510031830342788459718258721
#I  p+1 for n = 421584732115767299535558510031830342788459718258721
Residues : 2, Limit1 : 2000, Limit2 : 80000
#I  Residue no. 1
#I  Residue no. 2
#I  
#I  Elliptic Curves Method (ECM)
Curves = <func.>
Init. Limit1 = <func.>, Init. Limit2 = <func.>, Delta = <func.>
Number to be factored : 
20532514165758816624282961
#I  ECM for n = 20532514165758816624282961
#I  Digits : 26, Curves : 3
#I  Initial Limit1 : 200, Initial Limit2 : 20000, Delta : 200
#I  Curve no.      1 (     3), Limit1 :     200, Limit2 :    20000
#I  Curve no.      2 (     3), Limit1 :     400, Limit2 :    40000
#I  11-digit factor 12077430061 was found in second stage
#I  Intermediate result : [ [ 12077430061, 1700073116718901 ], [  ] ]
#I  
#I  Elliptic Curves Method (ECM)
Curves = <func.>
Init. Limit1 = <func.>, Init. Limit2 = <func.>, Delta = <func.>
Number to be factored : 
421584732115767299535558510031830342788459718258721
#I  ECM for n = 421584732115767299535558510031830342788459718258721
#I  Digits : 51, Curves : 27
#I  Initial Limit1 : 200, Initial Limit2 : 20000, Delta : 200
#I  Curve no.      1 (    27), Limit1 :     200, Limit2 :    20000
#I  Curve no.      2 (    27), Limit1 :     400, Limit2 :    40000
#I  Curve no.      3 (    27), Limit1 :     600, Limit2 :    60000
                             [ ... ]
#I  Curve no.     25 (    27), Limit1 :    5000, Limit2 :   500000
#I  Curve no.     26 (    27), Limit1 :    5200, Limit2 :   520000
#I  Curve no.     27 (    27), Limit1 :    5400, Limit2 :   540000
#I  
#I  Factors already found : [ 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 5, 5, 7, 11, 
  13, 31, 61, 73, 193, 283, 521, 2251, 303889, 1064341, 158024051, 
  12077430061, 146270666951, 4531280671081, 1700073116718901, 
  149430495783250750351, 20546596816316767296268561 ]
#I  
#I  Multiple Polynomial Quadratic Sieve (MPQS)
Number to be factored : 
421584732115767299535558510031830342788459718258721
#I  MPQS for n = 421584732115767299535558510031830342788459718258721
#I  Digits                     :         51
#I  Multiplier                 :          1
#I  Size of factor base        :       1326
#I  Prime powers to be sieved  :       1349
#I  Length of sieving interval :     131072
#I  Small prime limit          :        117
#I  Large prime limit          :    3500186
#I  Number of used a-factors   :          4
#I  Size of a-factors pool     :         52
#I  Initialization time        :         11 sec.
#I  
#I  Sieving
#I  
#I  Complete factorizations over the factor base   :       50
#I  Relations with a large prime factor            :        5
#I  Relations remaining to be found                :     1343
#I  Total factorizations with a large prime factor :      614
#I  Used polynomials                               :       67
#I  Elapsed runtime                                :       39 sec.
#I  Progress (relations)                           :        3 %
#I  
                             [ ... ]
#I  
#I  Complete factorizations over the factor base   :      651
#I  Relations with a large prime factor            :      826
#I  Relations remaining to be found                :        0
#I  Total factorizations with a large prime factor :     9164
#I  Used polynomials                               :     1021
#I  Elapsed runtime                                :      455 sec.
#I  Progress (relations)                           :      100 %
#I  
#I  Creating the exponent matrix
#I  Doing Gaussian Elimination, #rows = 1477, #columns = 1378
#I  Processing the zero rows
#I  Dependency no. 1 yielded no factor
                 [ ... ]
#I  Dependency no. 8 yielded no factor
#I  Dependency no. 9 yielded factor 26725378467920336641
#I  The factors are
[ 26725378467920336641, 15774696422795817479975816558881 ]
#I  Digit partition : [ 20, 32 ]
#I  MPQS runtime : 473.507 sec.

#I  Intermediate result : 
[ [ 26725378467920336641, 15774696422795817479975816558881 ], [  ] ]
#I  
#I  The result is
[ [ 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 5, 5, 7, 11, 13, 31, 61, 73, 193, 283, 
      521, 2251, 303889, 1064341, 158024051, 12077430061, 146270666951, 
      4531280671081, 1700073116718901, 26725378467920336641, 
      149430495783250750351, 20546596816316767296268561, 
      15774696422795817479975816558881 ], [  ] ]

#I  The total runtime was 799.408 sec

[ 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 5, 5, 7, 11, 13, 31, 61, 73, 193, 283, 
  521, 2251, 303889, 1064341, 158024051, 12077430061, 146270666951, 
  4531280671081, 1700073116718901, 26725378467920336641, 
  149430495783250750351, 20546596816316767296268561, 
  15774696422795817479975816558881 ]
]]>
</Log>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->
